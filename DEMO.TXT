


;*****************************************************************************
;
;       DEMO VOOR 3 LAMPEN (31,30,29) 24 OKT 1990
;
;*****************************************************************************


;       ADRESSES OF CIA#2 REGISTERS


CIA2BASE        EQU $DD00               ;BASE ADRESS OF CIA#2 

PRB             EQU CIA2BASE+1          ;PERIPHERAL DATA REG B
DDRB            EQU CIA2BASE+3          ;DATA DIRECTION REG B
TALO            EQU CIA2BASE+4          ;TIMER A LOW REGISTER
TAHI            EQU CIA2BASE+5          ;TIMER A HIGH REGISTER
TBLO            EQU CIA2BASE+6          ;TIMER B LOW REGISTER
TBHI            EQU CIA2BASE+7          ;TIMER B HIGH REGISTER
SDR             EQU CIA2BASE+$0C        ;SERIAL DATA REGISTER
ICR             EQU CIA2BASE+$0D        ;INTERRUPT CONTROL REGISTER
CRA             EQU CIA2BASE+$0E        ;CONTROL REG A
CRB             EQU CIA2BASE+$0F        ;CONTROL REG B

;       BITMASKS TO CONTROL THE CIA

STARTTB         EQU %00010001           ;BITMASK TO START TIMER B
STOPTB          EQU 0                   ;BITMASK TO STOP TIMER B
ENABLETB        EQU %10000010           ;BITMASK TO ENABLE TIMER B NMI'S
DISABLETB       EQU %00000010           ;BITMASK TO DISABLE TIMER B NMI'S
ENABLEFLAG      EQU %10010000           ;BITMASK TO ENABLE FLAG NMI'S
DISABLEFLAG     EQU %00010000           ;BITMASK TO DISABLE FLAG NMI'S
TBNMI           EQU %00000010           ;BITMASK TO CHECK FOR TIMER B NMI
FLAGNMI         EQU %00010000           ;BITMASK TO CHECK FOR FLAG NMI


NMIVEC          EQU $0318               ;ADRESS OF NMI VECTOR
OLDNMI          EQU $FE47               ;ORIGINAL NMI VECTOR

NROFSLICES      EQU 14                  ;# SLICES IN WHICH A PHASE IS DEVIDED
HALFPHASE       EQU NROFSLICES/2        ;FIRST SLICE OF NEG PHASE
ZEROCROSS       EQU HALFPHASE-1         ;LAST SLICE TO TRANSMIT SER DATA
SLICETIME       EQU $0570   ;(0570)     ;DURATION OF A SLICE (IN PHI2 TICKS) 

RATE            EQU $0004               ;SERIAL TRANSMISSION RATE

NROFLAMPS       EQU 32                  ;NUMBER OF LAMPS
NROFDATABYTES   EQU NROFLAMPS/2         ;NUMBER OF DATABYTES
BITMAPSIZE      EQU ZEROCROSS*4         ;SIZE OF LAMPDATA BITMAP

;
;       Memory map  
;

FREEZEROPG      EQU $A3                 ;START OF SOME FREE ZERO PAGE
PROGRAMSEG      EQU $8000               ;PROGRAM SEGMENT START ADRESS
DATASEG         EQU $6000               ;DATA SEGMENT START ADRESS

;
;       Zero-page variables and pointers
;

                ORG FREEZEROPG

LMPPTR          RMB 2                   ;POINTER TO LAMPDATA USED BY SETLMP
SLICECNT        RMB 1                   ;SLICE COUNTER
TEMPDATOUT      RMB 1                   ;TEMPORARY DATA DATOUT ROUTINE
DELAY10MS       RMB 1                   ;DECREMENTED EVERY 10 MS.
;
;       Tables and non-zeropage variables
;

                ORG DATASEG

LAMPBITMAP      RMB BITMAPSIZE          ;LAMP BITMAP
LAMPCODES       RMB NROFLAMPS           ;LAMP CODES 
TEMPTOBITM      RMB 1                   ;TEMPORARY DATA TOBITMAP ROUTINE
;
;       Program
;

                ORG PROGRAMSEG

;       JUMPTABLE TO AVAILABLE ROUTINES

                JMP START
                JMP INIT                ;INITIALIZE THE LAMPS DRIVER
                JMP SETNEW              ;DISPLAY A NEW PATTERN


;*****************************************************************************
;
;      INIT             15/10/90
;
;       Initialize the lampsteering interrupt system.
;
;       There are 3 different NMI possible:
;       FLAG, TB and RESTORE.
;
;       The RESTORE interrupt is caused by pressing the <restore>
;       key. This interrupt is ignored.
;
;       The FLAG and TB interrups both come from CIA 2. 
;       The FLAG is generated by a high to low transition on the
;       FLAG input pin. This transition is generated by hardware on
;       the first zero-cross of a full phase in the main power
;       supply. It comes approx every 20ms. (50Hz)
;       The TB interrupt is generated by the TIMER B section of 
;       the CIA. Every TB interrupt indicates the start of a new
;       timeSLICE. Every TB and FLAG interrupt, data is transmitted.
;
;       The FLAG interrupt disables itself and enables the TB.
;       The last TB interrupt disables TB intr's and enables FLAG.
;       
;       input:          none
;       output:         The old NMI is taken over by the new one.
;                       FLAG NMI enabled, timers A and B set.
;                       Hardware switched from RS232 to power-sync.
;       regs affected:  all
;
;*****************************************************************************

INIT            LDA #%01111111
                STA ICR                 ;DISABLE NMI'S
                                                        
                LDX #}NEWNMI
                LDY #{NEWNMI
                STX NMIVEC
                STY NMIVEC+1            ;INITIALIZE THE NMI VECTOR

                LDX #}RATE
                LDY #{RATE              ;TIMER A CONTROLS THE SPEED
                STX TALO                ;OF THE SERIAL PORT
                STY TAHI                ;SET RATE OF SERIAL TRANSMISSION
                LDA #%11010001          ;CONTINUOUS MODE
                STA CRA                 ;START TIMER A

                LDX #}SLICETIME
                LDY #{SLICETIME
                STX TBLO
                STY TBHI                ;SET DURATION OF ONE SLICE
                LDA #0
                STA CRB                 ;RESET TIMER B

                LDA #%00100000
                STA DDRB                ;PBJ OF USERPORT TO OUTPUT
                LDA PRB
                AND #%11011111
                STA PRB                 ;PBJ LOW TO ENABLE SYNC AT FLAG INPUT

                LDA #ENABLEFLAG          
                STA ICR                 ;ENABLE FLAG NMI

                RTS

;*****************************************************************************
;
;       NEWNMI          18/10/90
;
;       The new NMI dispatcher.
;       Find out what caused the NMI, then handle it by
;       calling the right handler. 
;
;       input:          none
;       output:         none
;       regs affected:  none
;
;*****************************************************************************
  
NEWNMI          SEI                     ;DISABLE IRQ'S
                PHA
                TYA
                PHA
                TXA
                PHA                     ;SAVE REGS

                LDA ICR                 ;GET CIA STATUS
                PHA                     ;SAVE STATUS 
                AND #TBNMI              ;TIMER B NMI?
                BEQ NE1                 ;NO -> JUMP  OVER
                JSR TB                  ;HANDLE TIMER B NMI
                JMP NEEXIT              ;EXIT DISPATCHER

NE1             PLA                     ;GET SAVED STATUS
                PHA                     ;LEAVE IT ON STACK
                AND #FLAGNMI            ;FLAG NMI?
                BEQ NE2                 ;NO -> JUMP OVER
                JSR FLAG                ;HANDLE FLAG NMI
                JMP NEEXIT              ;EXIT DISPATCHER

NE2             LDA #"R"                ;RESTORE KEY PRESSED
                JSR $FFD2               ;DISPLAY R

NEEXIT          PLA                     ;REMOVE STATUS 
                PLA                     ;RESTORE REGS
                TAX
                PLA
                TAY
                PLA
                RTI

;*****************************************************************************
;
;       NEWNMIRUN       15/10/90
;
;       Test wheter our NMI is running or not. 
;
;       input:          none
;       output:         C=1 our NMI, C=0 not our NMI
;       regs affected:  CCR
;
;*****************************************************************************

NEWNMIRUN       PHA                     ;SAVE A
                CLC                     ;ASSUME NOT RUNNING
                LDA NMIVEC              ;GET NMI VECTOR.LOW
                CMP #}NEWNMI            ;IS IT OUR VECTOR?
                BNE RUN1                ;NO -> EXIT
                LDA NMIVEC+1            ;GET NMI VECTOR.HIGH
                CMP #{NEWNMI            ;IS IT OUR VECTOR?
                BNE RUN1                ;NO -> EXIT
                SEC                     ;FLAG RUNNING
RUN1            PLA                     ;GET A
                RTS                     ;RETURN

;*****************************************************************************
;
;       FLAG            15/10/90
;
;       FLAG INTERRUPT handler. 
;       Disables FLAG, starts timer B, enables TB NMI.
;       Then call TB handler to transmit first data.
;
;       input:          none
;       output:         none
;       regs affected:  all
;
;*****************************************************************************
     
FLAG            LDA #STARTTB
                STA CRB                 ;START TIMER B
                LDA #DISABLEFLAG
                STA ICR                 ;DISABLE FLAG NMI
                LDA #ENABLETB
                STA ICR                 ;ENABLE TB NMI
                LDA #0
                STA SLICECNT            ;INITIALIZE SLICECNT;

                JSR TB                  ;DO FIRST SLICE

                RTS

;*****************************************************************************
;
;       TB              15/10/90
;
;       TIMER INTERRUPT handler.
;       Check SLICEnumber, transmit data, adjust SLICEnumber
;       If last SLICE then disable TB NMI and enable FLAG NMI.
;
;       This routine also decrements the DELAY10MS counter every
;       10 ms.
;
;       input:          none
;       output:         none
;       regs affected:  all
;
;*****************************************************************************

TB              LDA SLICECNT           
                CMP #ZEROCROSS          ;IS THIS THE POS HALF OF PHASE?
                BCC TB1                 ;YES -> GO ON
                SBC #HALFPHASE          ;ADJUST FOR NEG HALF OF PHASE
                CMP #ZEROCROSS          ;IS THIS THE NEG HALF OF PHASE?
                BCC TB1                 ;YES -> GO ON
                DEC DELAY10MS           ;ZERO-CROSSING -> ADJUST DELAY CNT
                JMP TB3                 ;READY 

;               SEND SERIAL DATA

TB1             ASL A                   ;A=ADJUSTED SLICECNT
                ASL A                   ;A=A*4
                TAX                     ;X=POINTER DO DATA IN LAMPBITMAP
                LDY #4                  ;Y=LOOPCOUNTER
                SEC                     ;DON'T WAIT FOR SDR EMPTY
TB2             LDA LAMPBITMAP,X        ;GET DATA TO TRANSMIT
                JSR DATOUT              ;TRANSMIT IT
                INX                     ;POINT TO NEXT DATAFIELD
                DEY                     ;ALL DONE?
                BNE TB2                 ;NO -> GO LOOP

TB3             LDA SLICECNT          
                CMP #NROFSLICES-1       ;WAS THIS THE LAST SLICE?
                BNE TBEXIT              ;NO -> WE ARE READY
                LDA #STOPTB             ;YES-> STOP GENERATING TIMER B NMI'S
                STA CRB                 ;SWITCH OFF TIMER B
                LDA #DISABLETB 
                STA ICR                 ;DON'T ALLOW TB NMI'S
                LDA #ENABLEFLAG
                STA ICR                 ;ENABLE FLAG NMI'S

TBEXIT          INC SLICECNT            ;ADJUST SLICECNT FOR NEXT SLICE
                RTS


;*****************************************************************************
;
;       DATOUT                          (not re-entrant!)
;
;       Transmit the serial data as fast as possible.
;       This routine polls the CIA to check for SDR empty.
;
;       input:          A=data
;                       C=1 don't check SDR empty
;                         0 wait for SDR empty
;       output:         C=0
;       regs affected:  CCR
;
;*****************************************************************************

DATOUT          BCS DA2                 ;WAIT FOR SDR EMPTY? NO -> JUMP
                STX TEMPDATOUT          ;SAVE X
                TAX                     ;SAVE DATA
                LDA #%00001000          ;SDR EMPTY TEST BIT
DA1             BIT ICR                 ;SDR EMPTY?
                BEQ DA1                 ;NO -> WAIT
                STX SDR                 ;TRANSMIT DATA
                TXA                     ;RESTORE DATA
                LDX TEMPDATOUT          ;RESTORE X
                JMP DA3                 ;EXIT
DA2             STA SDR                 ;TRANSMIT IT
DA3             CLC                     ;NEXT TIME WAIT FOR SDR EMPTY
                RTS

;*****************************************************************************
;
;       TOBITMAP        19/10/90        (not re-entrant!)
;
;       Used to update the lampbitmap for one lamp.
;       This routine should not affect the X register, because
;       it is used as the loopcounter in the calling routine.
;
;       input:          A=lampcode
;                       X=lampnumber
;       output:         corresponding bit in bitmap set
;       regs affected:  A,Y,CCR
;
;*****************************************************************************

TOBITMAP        CMP #0                  ;IS THE CODE ZERO?
                BEQ TBEND               ;YES -> READY
                SEC                     ;NO
                SBC #1                  ;DEC A
                ASL A
                ASL A                   ;A=A*4=SLICE OFFSET
                STA TEMPTOBITM          ;SAVE SLICE OFFSET

                TXA                     ;GET LAMPNUMBER
                LSR A                   ;LAMPNUMBER/8=
                LSR A                   ; BYTENUMBER OF CURRENT LAMP
                LSR A                   ; IN A SLICE  
                CLC
                ADC TEMPTOBITM          ;ADD SLICE OFFSET TO OBTAIN BYTE
                STA TEMPTOBITM          ;BYTE CONTAINING BIT TO SET

                TXA                     ;GET LAMPNUMBER
                AND #7                  ;GET BITNUMBER
                TAY
                LDA BITMSK,Y            ;GET BITMASK (A=2^(7-Y))

                LDY TEMPTOBITM          ;GET BYTENR
                ORA LAMPBITMAP,Y        ;SET BYTE
                STA LAMPBITMAP,Y        ;WRITE BACK

TBEND           RTS

BITMSK          BYTE 128,64,32,16,8,4,2,1

;*****************************************************************************
;
;       CLRBMP          15/10/90
;
;       Fill LAMPBITMAP with zero's.
;
;       input:          none
;       output:         LAMPBITMAP is cleared
;       regs affected:  A,X,CCR
;
;*****************************************************************************

CLRBMP          LDX #BITMAPSIZE-1       ;GET SIZE OF LAMP BITMAP
                LDA #0                  ;FILL WITH ZERO'S
CL1             STA LAMPBITMAP,X        ;CLEAR A BYTE
                DEX                     ;ALL DONE?
                BPL CL1                 ;NO -> GO LOOP
                RTS                     ;YES -> READY

;*****************************************************************************
;
;       SETNEW          18/10/90
;
;       Wait for zero-cross, then create a new lamp pattern.
;
;       input:          LMPPTR = pointer to packed lamp data
;       output:         LAMPCODES table, LAMPBITMAP 
;       regs affectes:  all
;
;*****************************************************************************

SETNEW          JSR NEWNMIRUN           ;IS THE LAMPSTEERING ON?
                BCC SE2                 ;NO -> DON'T SYNCRONIZE

SE1             LDA SLICECNT            ;GET SLICE NUMBER
                CMP #ZEROCROSS          ;ZERO-CROSSING?
                BNE SE1                 ;NO -> WAIT 

SE2             JSR EXPANDDATA          ;GENERATE LAMPCODES
                JSR CLRBMP              ;CLEAR BITMAP
                JSR SETLAMP             ;GENERATE NEW BITMAP

                RTS

;*****************************************************************************
;
;       EXPANDDATA      18/10/90
;
;       Routine to build the LAMPCODES table.
;
;       input:          LMPPTR = pointer to packed lamp data
;       output:         LAMPCODES table
;       regs affected:  all
;
;*****************************************************************************

EXPANDDATA      LDY #NROFDATABYTES-1    ;DO ALL DATABYTES
                LDX #NROFLAMPS-1        ;DO ALL LAMPS

EXP1            LDA (LMPPTR),Y          ;GET A DATABYTE
                AND #%00001111          ;GET LOW NIBBLE
                STA LAMPCODES,X         ;STORE IN TABLE
                DEX                     ;POINT TO NEXT CODEFIELD

                LDA (LMPPTR),Y          ;GET SAME DATABYTE
                LSR A
                LSR A
                LSR A
                LSR A                   ;NOW GET HIGH NIBBLE
                STA LAMPCODES,X         ;STORE IN TABLE
                DEX                     ;POINT TO NEXT CODEFIELD

                DEY                     ;LAST BYTE?
                BPL EXP1                ;NO -> GO LOOP

                RTS                     ;READY

;*****************************************************************************
;
;       SETLAMP         18/10/90
;
;       Routine to build the LAMPBITMAP from the LAMPCODES table
;
;       input:          LAMPCODES table
;       output:         LAMPBITMAP
;       regs affected:  all
;
;*****************************************************************************

SETLAMP         LDX #NROFLAMPS-1        ;DO ALL LAMPS
SETL1           LDA LAMPCODES,X         ;GET LAMPCODE
                JSR TOBITMAP            ;SET BIT IN BITMAP
                DEX                     ;ALL DONE?
                BPL SETL1               ;NO -> LOOP
                RTS                     ;YES -> READY

;*****************************************************************************
;
;       DELAYAMS
;
;       Pauses the program for A*10ms, if the lampdriver is running. 
;       If the timer is not running this routine returns without delay.
;
;       This routine doesn't disable IRQ's. Therefore the IRQ handlers
;       shouldn't run for more then 10ms!
;
;       input:          A=delay time in 10ms steps
;       output:         none
;       reg affected:   A
;
;*****************************************************************************

DELAYAMS        PHP                     ;SAVE CCR
                JSR NEWNMIRUN           ;IS THE TIMER RUNNING?
                BCC DELEXIT             ;NO -> EXIT
                STA DELAY10MS           ;STORE DELAYTIME IN COUNTER
DEL1            LDA DELAY10MS           ;IS IT ZERO?
                BNE DEL1                ;NO -> WAIT
DELEXIT         PLP                     ;GET CCR
                RTS                     ;YES -> RETURN





;*****************************************************************************
;
;       DEMO PROGRAM -- 3 LAMP KNIGHT RIDER 
;
;*****************************************************************************
        

SAMPLEDAT1      BYTE 0,0,0,0,0,0,0,0
                BYTE 0,0,0,0,0,0,$05,$00

SAMPLEDAT2      BYTE 0,0,0,0,0,0,0,0
                BYTE 0,0,0,0,0,0,$00,$04

SAMPLEDAT3      BYTE 0,0,0,0,0,0,0,0
                BYTE 0,0,0,0,0,0,$00,$45

SAMPLEDAT4      BYTE 0,0,0,0,0,0,0,0
                BYTE 0,0,0,0,0,0,$04,$50

SPEED           EQU 25


START           JSR INIT
MAINLOOP        LDX #}SAMPLEDAT1
                LDY #{SAMPLEDAT1
                STX LMPPTR
                STY LMPPTR+1
                JSR SETNEW
                LDA #SPEED 
                JSR DELAYAMS
                LDX #}SAMPLEDAT2
                LDY #{SAMPLEDAT2
                STX LMPPTR
                STY LMPPTR+1
                JSR SETNEW
                LDA #SPEED     
                JSR DELAYAMS
                LDX #}SAMPLEDAT3
                LDY #{SAMPLEDAT3
                STX LMPPTR
                STY LMPPTR+1
                JSR SETNEW
                LDA #SPEED     
                JSR DELAYAMS
                LDX #}SAMPLEDAT4
                LDY #{SAMPLEDAT4
                STX LMPPTR
                STY LMPPTR+1
                JSR SETNEW
                LDA #SPEED     
                JSR DELAYAMS
                JMP MAINLOOP            ;RUN FOREVER

                END.













